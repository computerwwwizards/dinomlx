# Build Process

The DINOMLX build process is designed to be incremental, cache-friendly, and optimized for performance. It follows a multi-stage pipeline:

## 1. Source Parsing

The compiler scans the `src` directory to build an initial understanding of the project.

*   **Pages**: `src/pages/*.html`
*   **Templates**: `src/templates/*.html` (and components)

### Candidates Registry (SSG)

A crucial part of this step is the initialization of the **Candidates Registry**.

*   The compiler scans the `src/candidates/*.css` directory.
*   It reads all CSS candidate definitions and loads them into an **in-memory JSON map**.
*   This map acts as a local database and the single source of truth for all available styles during the build.
*   When a template requests a candidate (e.g., `class="button-primary"`), the compiler queries this registry to retrieve the corresponding CSS rules.
*   This design avoids repeated disk I/O and ensures that missing candidates are detected early in the build process.

## 2. Dependency Resolution

For each component and page, the compiler resolves dependencies:

*   **Custom Components**: `c-component-name` tags are matched to their source template files.
    *   **Convention**: Directory separators in source paths are replaced by underscores in tag names (e.g., `templates/atoms/button.html` -> `<c-atoms_button>`).
*   **CSS Candidates**: Classes used in the template are validated against the in-memory Candidates Registry.
*   **Dynamic Attributes**: `_c_` attributes and `{{ }}` expressions are processed.
*   **Localization**: Internalization tags (`<i18n-key>`) are identified and prepared for extraction.

## 3. IR Generation

The resolved components and pages are transformed into the [Intermediate Representation (IR)](./intermediate-representation.md).

*   **Hashing**: Each component instance is assigned a unique hash based on its content and usage.
*   **Data Structure**: The component tree is flattened into a map of hashes (e.g., `hash_index` -> `{ slots: ... }`).
*   **Localization**: i18n strings are extracted into a dictionary, keyed by a unique hash (e.g., `$i18n#{hash_title}`).

## 4. Critical CSS Extraction

This is a key performance feature of DINOMLX.

1.  **Above-the-Fold Analysis**: The compiler identifies components that are visible in the initial viewport. This is determined by explicit markup (e.g., `<c-above-the-fold>`) or configuration.
2.  **Reference Tracing**: Starting from the root page and any `above_the_fold` references, the compiler traces the dependency graph to find all used CSS candidates.
3.  **CSS Composition**: The CSS rules for these candidates are retrieved from the **Candidates Registry** and deduplicated.
4.  **Inlining**: The resulting Critical CSS is inlined directly into the `<head>` of the final HTML page inside a `<style>` tag.
5.  **Deferral**: All other CSS (for components not visible initially or interactive states like `:hover`) is bundled into a separate CSS file (e.g., `deferable.css`) and loaded asynchronously.

## 5. HTML Generation

The final HTML files are generated by traversing the IR and stitching the content together.

*   **Slot Filling**: Content is injected into the appropriate slots (replacing `$#{hash_component}` placeholders).
*   **Localization**: The correct language strings are substituted for i18n placeholders (replacing `$i18n#{hash_key}`).
*   **Asset Injection**: Scripts, deferable CSS links, and other assets are injected.

## Directory Structure (Output)

The final output is typically stored in the `dist` directory:

```
dist/
  index.html            # Final page with inlined Critical CSS
  about.html
  shared/
    deferable.css       # Non-critical CSS loaded asynchronously
  assets/               # Images, fonts, etc.
```

## Performance Considerations

*   **In-Memory Registry**: Loading candidates into memory ensures extremely fast lookups during compilation.
*   **Incremental Builds**: Because the IR is hash-based, unchanged components do not need to be recompiled.
*   **Parallel Processing**: Parsing and IR generation can happen in parallel for different pages.
*   **Zero-Runtime Overhead**: The compilation happens at build time, resulting in static HTML that is fast to load and render.
